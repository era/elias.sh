<html>
  <head>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/a11y-dark.min.css">
	<meta charset="utf-8">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
<style>

:root {
    --base-font-size: 18px;
    --heading-multiplier: 1.5;
    
    --main-font: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
    --alt-font: 'JetBrains Mono', 'Source Code Pro', monospace;

    /* Rust-themed colors - inspired by Rust orange and dark themes */
    --rust-primary: #DEA584;        /* Rust orange/brown */
    --rust-secondary: #B7410E;      /* Darker rust */
    --rust-accent: #FF7F50;         /* Coral/orange accent */
    --rust-hover: #FFA07A;          /* Light salmon */
    --rust-visited: #CD5B45;        /* Tomato red */
    --rust-glow: rgba(222, 165, 132, 0.4);
    --terminal-link: #83C092;       /* Softer green that complements rust colors */
    
    /* Updated color scheme */
    --main-bg: #1A1A1A;            /* Dark gray instead of pure black */
    --secondary-bg: #252525;        /* Slightly lighter dark gray */
    --text-primary: #E8E8E8;
    --text-secondary: #B0B0B0;
    --glitch-color1: #DEA584;       /* Rust color for glitch */
    --glitch-color2: #83C092;       /* Terminal green for glitch */
}

img {
  max-width: 900px;
  width: auto;
  height: auto;
}

body {
    background-color: var(--main-bg);
    color: var(--text-primary);
    font-family: var(--main-font);
    line-height: 1.7;
    font-size: 18px;
    margin: 0;
    padding: 0;
    overflow-x: hidden;
}

h1, h2, h3 {
    color: var(--text-primary);
    font-weight: 600; /* Slightly bolder for better readability */
    text-transform: uppercase;
    letter-spacing: 2px;
    font-family: var(--alt-font);
}

h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    position: relative;
    display: inline-block;
    color: var(--rust-primary);
}

h1::after {
    content: '_';
    animation: blink 1s step-end infinite;
    color: var(--rust-accent);
    margin-left: 5px;
}

.rust-crab {
    display: inline-block;
    margin-left: 10px;
    font-size: 1.8rem;
    animation: crab-walk 3s ease-in-out infinite;
}

@keyframes crab-walk {
    0%, 100% { transform: translateX(0) rotate(0deg); }
    25% { transform: translateX(5px) rotate(-5deg); }
    75% { transform: translateX(-5px) rotate(5deg); }
}

@keyframes blink {
    from, to { opacity: 0; }
    50% { opacity: 1; }
}

nav {
    background-color: rgba(37, 37, 37, 0.95); /* Using secondary bg with transparency */
    backdrop-filter: blur(5px);
    padding: 1rem;
    position: sticky;
    top: 0;
    z-index: 100;
    border-bottom: 1px solid var(--rust-primary);
}

nav ul {
    display: flex;
    justify-content: center;
    list-style: none;
    padding: 0;
    margin: 0;
    gap: 2rem;
}

main {
    max-width: 1000px;
    margin: 2rem auto;
    padding: 0 2rem;
}

footer {
    text-align: center;
    padding: 2rem;
    font-size: 0.8rem;
    color: var(--text-secondary);
    border-top: 1px solid var(--rust-primary);
    background-color: var(--secondary-bg);
}

/* Enhanced glitch effect with rust colors */
.glitch {
    position: relative;
}


/* Terminal-like elements with rust theme */
.terminal {
    background-color: var(--secondary-bg);
    border: 1px solid var(--rust-primary);
    padding: 1rem;
    font-family: var(--main-font);
    position: relative;
    margin: 2rem 0;
    border-radius: 4px;
    box-shadow: 0 0 15px var(--rust-glow);
}

.terminal::before {
    content: '$';
    position: absolute;
    left: 0.5rem;
    top: 0.5rem;
    color: var(--rust-accent);
    font-weight: bold;
}

.terminal p {
    margin: 0;
    padding-left: 1.5rem;
    color: var(--text-secondary);
}

/* Cargo.toml style code block */
.code-block {
    background-color: #2D2D2D;
    border-left: 4px solid var(--rust-primary);
    padding: 1rem;
    margin: 1.5rem 0;
    font-family: var(--main-font);
    font-size: 0.9rem;
    overflow-x: auto;
}

.code-key { color: #83C092; }      /* Green for keys */
.code-string { color: #D19A66; }   /* Orange for strings */
.code-comment { color: #5C6370; }  /* Gray for comments */
.code-number { color: #D19A66; }   /* Orange for numbers */

/* Responsive design */
@media (max-width: 768px) {
    nav ul {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    h1 {
        font-size: 1.8rem;
    }
}

a {
    color: var(--rust-accent);
    text-decoration: none;
    position: relative;
    font-weight: bold;
    transition: all 0.3s ease;
    padding: 0 2px;
}

a:hover {
    color: var(--rust-hover);
    text-shadow: 0 0 8px var(--rust-glow);
    background-color: rgba(222, 165, 132, 0.1);
}

/* Underline animation */
a::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 2px;
    bottom: -2px;
    left: 0;
    background: linear-gradient(90deg, var(--rust-accent), transparent);
    transform: scaleX(0);
    transform-origin: bottom right;
    transition: transform 0.4s ease;
}



/* Visited links */
a:visited {
    color: var(--rust-visited);
}

/* Active/focused links */
a:active, a:focus {
    color: var(--text-primary);
    outline: 1px dotted var(--rust-accent);
    background-color: rgba(222, 165, 132, 0.2);
}

/* Special link styles for navigation */
nav a {
    padding: 0.5rem 1rem;
    border: 1px solid transparent;
    transition: all 0.3s ease;
}

nav a:hover {
    border: 1px solid var(--rust-accent);
    background-color: rgba(222, 165, 132, 0.15);
    border-radius: 3px;
}

nav a::after {
    display: none;
}

/* Terminal-style links */
.terminal a {
    color: var(--terminal-link);
}

.terminal a:hover {
    color: #A7D8B9;
    text-shadow: 0 0 5px rgba(131, 192, 146, 0.5);
}

.terminal a::after {
    background: linear-gradient(90deg, var(--terminal-link), transparent);
}

.center-image {
    display: flex;
    justify-content: center;
    position: relative;
}

.center-image img {
    width: 150px;
}

blockquote {
    font-family: var(--alt-font);
    font-size: 1.2rem;
    color: var(--text-secondary);
    border-left: 3px solid var(--rust-primary);
    background: rgba(37, 37, 37, 0.5);
    padding: 1.5rem 2rem;
    margin: 2rem 0;
    position: relative;
    line-height: 1.8;
    border-radius: 0 4px 4px 0;
    box-shadow: 0 0 15px rgba(222, 165, 132, 0.1);
    overflow: hidden;
}

blockquote::before {
    content: '//';
    font-family: var(--main-font);
    font-size: 1.5rem;
    color: var(--rust-glow);
    position: absolute;
    left: 0.5rem;
    top: 0.5rem;
    line-height: 1;
    opacity: 0.5;
}

blockquote::after {
    content: '';
    position: absolute;
    right: 0;
    bottom: 0;
    width: 30%;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--rust-primary), transparent);
}

blockquote p {
    margin: 0;
    position: relative;
    z-index: 1;
}

blockquote footer {
    font-size: 0.9rem;
    text-align: right;
    margin-top: 1rem;
    color: var(--rust-accent);
    font-style: normal;
    border: none;
    background: none;
}

blockquote footer::before {
    content: 'â€” ';
}


img {
    filter: brightness(0.8) contrast(1.1) sepia(0.1);
    transition: filter 0.4s ease;
}


/* Rust specific status indicators */
.status-compiling {
    color: var(--rust-primary);
    animation: pulse 2s infinite;
}

.status-success {
    color: var(--terminal-link);
}

.status-error {
    color: var(--rust-secondary);
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

</style>
  <title>Kernel Mode, Cybersecurity and Rust </title>

  </head>
  <body class="hack main container">
	<a href="https://elias.sh">< back to home</a>
	<main>
	<h1>Kernel Mode, Cybersecurity and Rust</h1>
	<h6>2025-09-06</h6>
	<p>Since last year, I have been working in cybersecurity. I mostly worked on the data ingestion side of things, but lately I started working on the agents that run on user machines. I want to take this opportunity to write a little bit about User Space and Kernel Space, but before jumping into it, let me explain the macro view of a cybersecurity product like EDR (Endpoint Detection and Response).</p>
<p>First, what is EDR? Well, corporations don't want their information to leak, and a common attack is through employees' laptops (endpoints). In a way, you can think of an EDR as a system that monitors endpoints and tries to respond to malware and other cyber threats. To do that, it needs to look at your computer activities and categorise actions as benign or (possibly) malicious. Unlike an anti-virus, which performs most of this analysis locally, most EDR agents (the software running on your computer) send that data to a centralised place where it can take an action based on aggregated information (e.g. all laptops of the company).</p>
<p>This is not that different from an observability pipeline (which has been my focus for the last ~3 years before moving to Japan). You basically have an agent on the computers sending telemetry data to a system that should perform an action based on a set of rules.</p>
<p>The difference is that when we are talking about observability of the services we have built, we control the metrics and logs we expose. We don't need to inject something to collect that information for us. Although you may see people using eBFP for continuous profiling.</p>
<p>If we want to observe the behaviour of the user's computer, we really need a &quot;spyware&quot; able to look at which processes are running and any I/O they are doing. But as you may imagine, an application cannot randomly poke other applications to see what they are doing. Those applications run in what we call User Mode.  In User Mode, you have a virtual memory (the address the application sees is not the real physical addresses), and to access the hardware, for example, the disk, the application needs to ask the OS for it (which will verify permissions and so on). The OS runs in Kernel Mode, which allows it to have control over hardware and all applications. When an application needs to ask for something, it does a syscall.</p>
<p>As you may have thought by now, we need &quot;two applications&quot;, one running in User Mode to send the telemetry data to the cloud and another running in Kernel Mode.  How can we do it? Well, it's going to depend on which OS we are talking about, but for most of them, a common option is to run a Kernel Driver. The problem with kernel drivers is that any bug in them may cause the whole system to crash (remember the number of issues this has caused Microsoft). In Linux, we can <a href="https://redcanary.com/blog/threat-detection/ebpf-for-security/">use eBPF for this</a>. eBPF runs on a virtual machine inside the kernel; the main advantage is that you can run your code in kernel mode without fearing a bug will crash the whole system.</p>
<p>You may know that most companies outside tech use Windows machines. On Windows, you don't have eBPF; you have to write your own kernel driver for that. Although Microsoft is heavily investing in Rust, making it easier to write applications with it thanks to <a href="https://github.com/microsoft/windows-rs">windows-rs</a> and <a href="https://github.com/microsoft/windows-drivers-rs">windows-drivers-rs</a>, we are far from being able to write Windows kernel drivers with Rust. The solution is to write an agent in Rust, which communicates with a C++ kernel driver using <a href="https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/IO/fn.DeviceIoControl.html">DeviceIoControl</a>.</p>
<p><a href="https://techcommunity.microsoft.com/blog/windowsdriverdev/towards-rust-in-windows-drivers/4449718">There is a near future where we can write all those layers in Rust</a>, but we are not there yet.</p>
	</main>
        <div class="footer">
      Built with <a href="https://github.com/era/tinylang">TinyLang</a> + <a href="https://github.com/era/squid">Squid</a>.
    </div>

  </body>
</html>
