<html>
  <head>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/a11y-dark.min.css">
	<meta charset="utf-8">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
<style>

:root {
    --base-font-size: 18px;
    --heading-multiplier: 1.5;
    
    --main-font: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
    --alt-font: 'JetBrains Mono', 'Source Code Pro', monospace;

    /* Rust-themed colors - inspired by Rust orange and dark themes */
    --rust-primary: #DEA584;        /* Rust orange/brown */
    --rust-secondary: #B7410E;      /* Darker rust */
    --rust-accent: #FF7F50;         /* Coral/orange accent */
    --rust-hover: #FFA07A;          /* Light salmon */
    --rust-visited: #CD5B45;        /* Tomato red */
    --rust-glow: rgba(222, 165, 132, 0.4);
    --terminal-link: #83C092;       /* Softer green that complements rust colors */
    
    /* Updated color scheme */
    --main-bg: #1A1A1A;            /* Dark gray instead of pure black */
    --secondary-bg: #252525;        /* Slightly lighter dark gray */
    --text-primary: #E8E8E8;
    --text-secondary: #B0B0B0;
    --glitch-color1: #DEA584;       /* Rust color for glitch */
    --glitch-color2: #83C092;       /* Terminal green for glitch */
}

img {
  max-width: 900px;
  width: auto;
  height: auto;
}

body {
    background-color: var(--main-bg);
    color: var(--text-primary);
    font-family: var(--main-font);
    line-height: 1.7;
    font-size: 18px;
    margin: 0;
    padding: 0;
    overflow-x: hidden;
}

h1, h2, h3 {
    color: var(--text-primary);
    font-weight: 600; /* Slightly bolder for better readability */
    text-transform: uppercase;
    letter-spacing: 2px;
    font-family: var(--alt-font);
}

h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    position: relative;
    display: inline-block;
    color: var(--rust-primary);
}

h1::after {
    content: '_';
    animation: blink 1s step-end infinite;
    color: var(--rust-accent);
    margin-left: 5px;
}

.rust-crab {
    display: inline-block;
    margin-left: 10px;
    font-size: 1.8rem;
    animation: crab-walk 3s ease-in-out infinite;
}

@keyframes crab-walk {
    0%, 100% { transform: translateX(0) rotate(0deg); }
    25% { transform: translateX(5px) rotate(-5deg); }
    75% { transform: translateX(-5px) rotate(5deg); }
}

@keyframes blink {
    from, to { opacity: 0; }
    50% { opacity: 1; }
}

nav {
    background-color: rgba(37, 37, 37, 0.95); /* Using secondary bg with transparency */
    backdrop-filter: blur(5px);
    padding: 1rem;
    position: sticky;
    top: 0;
    z-index: 100;
    border-bottom: 1px solid var(--rust-primary);
}

nav ul {
    display: flex;
    justify-content: center;
    list-style: none;
    padding: 0;
    margin: 0;
    gap: 2rem;
}

main {
    max-width: 1200px;
    margin: 2rem auto;
    padding: 0 2rem;
}

footer {
    text-align: center;
    padding: 2rem;
    font-size: 0.8rem;
    color: var(--text-secondary);
    border-top: 1px solid var(--rust-primary);
    background-color: var(--secondary-bg);
}

/* Enhanced glitch effect with rust colors */
.glitch {
    position: relative;
}


/* Terminal-like elements with rust theme */
.terminal {
    background-color: var(--secondary-bg);
    border: 1px solid var(--rust-primary);
    padding: 1rem;
    font-family: var(--main-font);
    position: relative;
    margin: 2rem 0;
    border-radius: 4px;
    box-shadow: 0 0 15px var(--rust-glow);
}

.terminal::before {
    content: '$';
    position: absolute;
    left: 0.5rem;
    top: 0.5rem;
    color: var(--rust-accent);
    font-weight: bold;
}

.terminal p {
    margin: 0;
    padding-left: 1.5rem;
    color: var(--text-secondary);
}

/* Cargo.toml style code block */
.code-block {
    background-color: #2D2D2D;
    border-left: 4px solid var(--rust-primary);
    padding: 1rem;
    margin: 1.5rem 0;
    font-family: var(--main-font);
    font-size: 0.9rem;
    overflow-x: auto;
}

.code-key { color: #83C092; }      /* Green for keys */
.code-string { color: #D19A66; }   /* Orange for strings */
.code-comment { color: #5C6370; }  /* Gray for comments */
.code-number { color: #D19A66; }   /* Orange for numbers */

/* Responsive design */
@media (max-width: 768px) {
    nav ul {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    h1 {
        font-size: 1.8rem;
    }
}

a {
    color: var(--rust-accent);
    text-decoration: none;
    position: relative;
    font-weight: bold;
    transition: all 0.3s ease;
    padding: 0 2px;
}

a:hover {
    color: var(--rust-hover);
    text-shadow: 0 0 8px var(--rust-glow);
    background-color: rgba(222, 165, 132, 0.1);
}

/* Underline animation */
a::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 2px;
    bottom: -2px;
    left: 0;
    background: linear-gradient(90deg, var(--rust-accent), transparent);
    transform: scaleX(0);
    transform-origin: bottom right;
    transition: transform 0.4s ease;
}



/* Visited links */
a:visited {
    color: var(--rust-visited);
}

/* Active/focused links */
a:active, a:focus {
    color: var(--text-primary);
    outline: 1px dotted var(--rust-accent);
    background-color: rgba(222, 165, 132, 0.2);
}

/* Special link styles for navigation */
nav a {
    padding: 0.5rem 1rem;
    border: 1px solid transparent;
    transition: all 0.3s ease;
}

nav a:hover {
    border: 1px solid var(--rust-accent);
    background-color: rgba(222, 165, 132, 0.15);
    border-radius: 3px;
}

nav a::after {
    display: none;
}

/* Terminal-style links */
.terminal a {
    color: var(--terminal-link);
}

.terminal a:hover {
    color: #A7D8B9;
    text-shadow: 0 0 5px rgba(131, 192, 146, 0.5);
}

.terminal a::after {
    background: linear-gradient(90deg, var(--terminal-link), transparent);
}

.center-image {
    display: flex;
    justify-content: center;
    position: relative;
}

.center-image img {
    width: 150px;
}

blockquote {
    font-family: var(--alt-font);
    font-size: 1.2rem;
    color: var(--text-secondary);
    border-left: 3px solid var(--rust-primary);
    background: rgba(37, 37, 37, 0.5);
    padding: 1.5rem 2rem;
    margin: 2rem 0;
    position: relative;
    line-height: 1.8;
    border-radius: 0 4px 4px 0;
    box-shadow: 0 0 15px rgba(222, 165, 132, 0.1);
    overflow: hidden;
}

blockquote::before {
    content: '//';
    font-family: var(--main-font);
    font-size: 1.5rem;
    color: var(--rust-glow);
    position: absolute;
    left: 0.5rem;
    top: 0.5rem;
    line-height: 1;
    opacity: 0.5;
}

blockquote::after {
    content: '';
    position: absolute;
    right: 0;
    bottom: 0;
    width: 30%;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--rust-primary), transparent);
}

blockquote p {
    margin: 0;
    position: relative;
    z-index: 1;
}

blockquote footer {
    font-size: 0.9rem;
    text-align: right;
    margin-top: 1rem;
    color: var(--rust-accent);
    font-style: normal;
    border: none;
    background: none;
}

blockquote footer::before {
    content: 'â€” ';
}


img {
    filter: brightness(0.8) contrast(1.1) sepia(0.1);
    transition: filter 0.4s ease;
}


/* Rust specific status indicators */
.status-compiling {
    color: var(--rust-primary);
    animation: pulse 2s infinite;
}

.status-success {
    color: var(--terminal-link);
}

.status-error {
    color: var(--rust-secondary);
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

</style>
  <title>EDR, Rust and Apple </title>

  </head>
  <body class="hack main container">
	<a href="https://elias.sh">< back to home</a>
	<main>
	<h1>EDR, Rust and Apple</h1>
	<h6>2025-11-07</h6>
	<p><a href="https://www.elias.sh/posts/kernel-mode-and-cybersecurity">In the last post</a>, I described a little bit about EDR and how we can implement it for Windows. If you look closer at what I described, you are going to see a clear pattern:</p>
<ol>
<li>We have a Driver hook up to certain events from the kernel that sends this info to a user-mode application</li>
<li>The user-mode application reads the information about the event and makes a decision (&quot;Inline Threat Prevention&quot;)</li>
</ol>
<p>As we discussed previously, building a driver is hard, and any mistake can make your whole system restart. Imagine every single EDR provider building their own drivers and making repeated mistakes (because everything is proprietary). This is not good for all the parts.</p>
<p>Apple has a better way of implementing this, which is called &quot;<a href="https://developer.apple.com/documentation/endpointsecurity">endpoint security</a>&quot;. As they describe it: &quot;Endpoint Security is a C API for monitoring system events for potentially malicious activity. Your client registers with Endpoint Security to authorize pending events, or receive notifications of events that already occurred. These events include process executions, mounting file systems, forking processes, and raising signals.&quot;</p>
<p>In a way, it's like Apple already wrote the driver for us, and we just need to consume the messages sent from them on our User-mode application. Yay, perfect, one less source of mistakes, right?</p>
<p>There is only one problem, it's a C API. If you know me, you know I'm interested in Rust. So how can we use this to build a Rust UserMode EDR application? Well, <a href="https://github.com/HarfangLab">HarfangLab</a> did a lot of the hard work for us and created a safe abstraction for us: endpoint_sec.</p>
<p>We basically need two things, first <a href="https://docs.rs/endpoint-sec/0.4.3/endpoint_sec/struct.Client.html#method.new">we need to create a client able to handle the different messages types</a>:</p>
<pre><code class="language-rust">
endpoint_sec::Client::new(|client: &amp;mut endpoint_sec::Client, message: endpoint_sec::Message| {
    // try not to block here and reply very fast to AUTH messages
    // if you are too slow the system may kill your EDR application, but worst than that:
    // Messages are handled strictly serially and in the order they are delivered.
    // Returning control from the handler causes the next available message to be dequeued.
   match message.event_type() {
      endpoint_sec_sys::es_event_type_t::ES_EVENT_TYPE_AUTH_EXEC =&gt; todo!(),
      _ =&gt; todo!(),
   };

}).unwrap();
</code></pre>
<p>Second we need to subscribe to the different events with <a href="https://docs.rs/endpoint-sec/0.4.3/endpoint_sec/struct.Client.html#method.subscribe">subscribe</a>.</p>
<p>There are two types of messages: Notify and Auth. Notify messages are notification only. The event already happened and the system is just letting us know. The Auth messages on the other hand are messages that we need to authorize (using a <a href="https://docs.rs/endpoint-sec/0.4.3/endpoint_sec/struct.Client.html#method.respond_auth_result">special function from our client</a>).</p>
<p>So yeah, while an EDR product 100% written in Rust is a bit complicated on Windows, it seems like a reality on MacOS! So reality, that maybe <a href="https://harfanglab.io/">Harfanglab</a> is already doing it? Not sure, but we have to thank them for the opensource crate!</p>
	</main>
        <div class="footer">
      Built with <a href="https://github.com/era/tinylang">TinyLang</a> + <a href="https://github.com/era/squid">Squid</a>.
    </div>

  </body>
</html>
